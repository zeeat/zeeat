{"version":3,"sources":["resources/SVGLoader.js","resources/helpers.js","index.js"],"names":["SVGLoader","manager","this","undefined","DefaultLoadingManager","prototype","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","text","parse","value","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","Object","assign","hasAttribute","fill","getAttribute","isVisible","getReflection","a","b","parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","splice","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","currentTransform","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","scale","set","tan","premultiply","parseTransformNode","copy","push","getNodeTransform","nodeName","ShapePath","color","setStyle","point","Vector2","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","trim","numbers","j","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","parsePathNode","w","h","parseRectNode","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","transfVec2","v2","tempV3","applyMatrix3","isTransformRotated","tempV2","Vector3","n","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","nodes","childNodes","pop","DOMParser","parseFromString","documentElement","doubleSide","THREE","deg","degToRad","colors","svgs","map","name","concat","Promise","resolve","shapes","flatten","group","toShapes","shape","Shape","_ref","rotation","position","opacity","react_default","createElement","three","mesh","interpolate","z","meshPhongMaterial","attach","side","depthWrite","transparent","args","Scene","_useState","useState","_useState2","slicedToArray","page","setPage","_useState3","_useState4","setShapes","useEffect","setInterval","then","useSpring","transitions","useTransition","item","uuid","objectSpread","from","enter","leave","config","mass","tension","friction","precision","order","trail","lazy","unique","reset","Fragment","depthTest","_ref2","key","props","ReactDOM","render","class","dist","invalidateFrameloop","camera","fov","near","far","intensity","href","children","document","getElementById"],"mappings":"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","file":"static/js/main.49fd6e23.chunk.js","sourcesContent":["import { DefaultLoadingManager, FileLoader, Matrix3, Path, ShapePath, Vector2, Vector3 } from 'three'\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n * @author yomboprime / https://yombo.org\n */\n\nvar SVGLoader = function(manager) {\n  this.manager = manager !== undefined ? manager : DefaultLoadingManager\n}\n\nSVGLoader.prototype = {\n  constructor: SVGLoader,\n\n  load: function(url, onLoad, onProgress, onError) {\n    var scope = this\n\n    var loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.load(\n      url,\n      function(text) {\n        onLoad(scope.parse(text))\n      },\n      onProgress,\n      onError\n    )\n  },\n\n  setPath: function(value) {\n    this.path = value\n    return this\n  },\n\n  parse: function(text) {\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return\n\n      var transform = getNodeTransform(node)\n\n      var path = null\n\n      switch (node.nodeName) {\n        case 'svg':\n          break\n\n        case 'g':\n          style = parseStyle(node, style)\n          break\n\n        case 'path':\n          style = parseStyle(node, style)\n          if (node.hasAttribute('d') && isVisible(style)) path = parsePathNode(node, style)\n          break\n\n        case 'rect':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parseRectNode(node, style)\n          break\n\n        case 'polygon':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parsePolygonNode(node, style)\n          break\n\n        case 'polyline':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parsePolylineNode(node, style)\n          break\n\n        case 'circle':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parseCircleNode(node, style)\n          break\n\n        case 'ellipse':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parseEllipseNode(node, style)\n          break\n\n        case 'line':\n          style = parseStyle(node, style)\n          if (isVisible(style)) path = parseLineNode(node, style)\n          break\n      }\n\n      if (path) {\n        transformPath(path, currentTransform)\n\n        paths.push(path)\n      }\n\n      var nodes = node.childNodes\n\n      for (var i = 0; i < nodes.length; i++) {\n        parseNode(nodes[i], style)\n      }\n\n      if (transform) {\n        currentTransform.copy(transformStack.pop())\n      }\n    }\n\n    function parsePathNode(node, style) {\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n\n      var point = new Vector2()\n      var control = new Vector2()\n\n      var firstPoint = new Vector2()\n      var isFirstPoint = true\n      var doSetFirstPoint = false\n\n      var d = node.getAttribute('d')\n\n      // console.log( d );\n\n      var commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n      for (var i = 0, l = commands.length; i < l; i++) {\n        var command = commands[i]\n\n        var type = command.charAt(0)\n        var data = command.substr(1).trim()\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true\n          isFirstPoint = false\n        }\n\n        switch (type) {\n          case 'M':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'H':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'V':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'L':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'C':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5])\n              control.x = numbers[j + 2]\n              control.y = numbers[j + 3]\n              point.x = numbers[j + 4]\n              point.y = numbers[j + 5]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'S':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3]\n              )\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'Q':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'T':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x)\n              var ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'A':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 7) {\n              var start = point.clone()\n              point.x = numbers[j + 5]\n              point.y = numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          //\n\n          case 'm':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'h':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'v':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'l':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'c':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5]\n              )\n              control.x = point.x + numbers[j + 2]\n              control.y = point.y + numbers[j + 3]\n              point.x += numbers[j + 4]\n              point.y += numbers[j + 5]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 's':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3]\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'q':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3])\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 't':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n              var rx = getReflection(point.x, control.x)\n              var ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = point.x + numbers[j + 0]\n              point.y = point.y + numbers[j + 1]\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          case 'a':\n            var numbers = parseFloats(data)\n            for (var j = 0, jl = numbers.length; j < jl; j += 7) {\n              var start = point.clone()\n              point.x += numbers[j + 5]\n              point.y += numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point)\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n            break\n\n          //\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint)\n              path.currentPath.currentPoint.copy(point)\n              isFirstPoint = true\n            }\n            break\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false\n      }\n\n      return path\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n      // Ensure radii are positive\n      rx = Math.abs(rx)\n      ry = Math.abs(ry)\n\n      // Compute (x1â², y1â²)\n      var dx2 = (start.x - end.x) / 2.0\n      var dy2 = (start.y - end.y) / 2.0\n      var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n      var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n      // Compute (cxâ², cyâ²)\n      var rxs = rx * rx\n      var rys = ry * ry\n      var x1ps = x1p * x1p\n      var y1ps = y1p * y1p\n\n      // Ensure radii are large enough\n      var cr = x1ps / rxs + y1ps / rys\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        var s = Math.sqrt(cr)\n        rx = s * rx\n        ry = s * ry\n        rxs = rx * rx\n        rys = ry * ry\n      }\n\n      var dq = rxs * y1ps + rys * x1ps\n      var pq = (rxs * rys - dq) / dq\n      var q = Math.sqrt(Math.max(0, pq))\n      if (large_arc_flag === sweep_flag) q = -q\n      var cxp = (q * rx * y1p) / ry\n      var cyp = (-q * ry * x1p) / rx\n\n      // Step 3: Compute (cx, cy) from (cxâ², cyâ²)\n      var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n      var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n      // Step 4: Compute Î¸1 and ÎÎ¸\n      var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      var dot = ux * vx + uy * vy\n      var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n      var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang\n      return ang\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node, style) {\n      var x = parseFloat(node.getAttribute('x') || 0)\n      var y = parseFloat(node.getAttribute('y') || 0)\n      var rx = parseFloat(node.getAttribute('rx') || 0)\n      var ry = parseFloat(node.getAttribute('ry') || 0)\n      var w = parseFloat(node.getAttribute('width'))\n      var h = parseFloat(node.getAttribute('height'))\n\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n      path.moveTo(x + 2 * rx, y)\n      path.lineTo(x + w - 2 * rx, y)\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry)\n      path.lineTo(x + w, y + h - 2 * ry)\n      if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h)\n      path.lineTo(x + 2 * rx, y + h)\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry)\n      }\n\n      path.lineTo(x, y + 2 * ry)\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y, x, y, x + 2 * rx, y)\n      }\n\n      return path\n    }\n\n    function parsePolygonNode(node, style) {\n      function iterator(match, a, b) {\n        var x = parseFloat(a)\n        var y = parseFloat(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g\n\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n\n      var index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = true\n\n      return path\n    }\n\n    function parsePolylineNode(node, style) {\n      function iterator(match, a, b) {\n        var x = parseFloat(a)\n        var y = parseFloat(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g\n\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n\n      var index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    function parseCircleNode(node, style) {\n      var x = parseFloat(node.getAttribute('cx'))\n      var y = parseFloat(node.getAttribute('cy'))\n      var r = parseFloat(node.getAttribute('r'))\n\n      var subpath = new Path()\n      subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseEllipseNode(node, style) {\n      var x = parseFloat(node.getAttribute('cx'))\n      var y = parseFloat(node.getAttribute('cy'))\n      var rx = parseFloat(node.getAttribute('rx'))\n      var ry = parseFloat(node.getAttribute('ry'))\n\n      var subpath = new Path()\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n      var path = new ShapePath()\n      path.color.setStyle(style.fill)\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseLineNode(node, style) {\n      var x1 = parseFloat(node.getAttribute('x1'))\n      var y1 = parseFloat(node.getAttribute('y1'))\n      var x2 = parseFloat(node.getAttribute('x2'))\n      var y2 = parseFloat(node.getAttribute('y2'))\n\n      var path = new ShapePath()\n      path.moveTo(x1, y1)\n      path.lineTo(x2, y2)\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style) // clone style\n\n      if (node.hasAttribute('fill')) style.fill = node.getAttribute('fill')\n      if (node.style.fill !== '') style.fill = node.style.fill\n\n      return style\n    }\n\n    function isVisible(style) {\n      return style.fill !== 'none' && style.fill !== 'transparent'\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a)\n    }\n\n    function parseFloats(string) {\n      var array = string.split(/[\\s,]+|(?=\\s?[+\\-])/)\n\n      for (var i = 0; i < array.length; i++) {\n        var number = array[i]\n\n        // Handle values like 48.6037.7.8\n        // TODO Find a regex for this\n\n        if (number.indexOf('.') !== number.lastIndexOf('.')) {\n          var split = number.split('.')\n\n          for (var s = 2; s < split.length; s++) {\n            array.splice(i + s - 1, 0, '0.' + split[s])\n          }\n        }\n\n        array[i] = parseFloat(number)\n      }\n\n      return array\n    }\n\n    function getNodeTransform(node) {\n      if (!node.hasAttribute('transform')) {\n        return null\n      }\n\n      var transform = parseTransformNode(node)\n\n      if (transform) {\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1])\n        }\n\n        currentTransform.copy(transform)\n        transformStack.push(transform)\n      }\n\n      return transform\n    }\n\n    function parseTransformNode(node) {\n      var transform = new Matrix3()\n      var currentTransform = tempTransform0\n      var transformsTexts = node.getAttribute('transform').split(' ')\n\n      for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n        var transformText = transformsTexts[tIndex]\n        var openParPos = transformText.indexOf('(')\n        var closeParPos = transformText.indexOf(')')\n\n        if (openParPos > 0 && openParPos < closeParPos) {\n          var transformType = transformText.substr(0, openParPos)\n\n          var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1))\n\n          currentTransform.identity()\n\n          switch (transformType) {\n            case 'translate':\n              if (array.length >= 1) {\n                var tx = array[0]\n                var ty = tx\n\n                if (array.length >= 2) {\n                  ty = array[1]\n                }\n\n                currentTransform.translate(tx, ty)\n              }\n\n              break\n\n            case 'rotate':\n              if (array.length >= 1) {\n                var angle = 0\n                var cx = 0\n                var cy = 0\n\n                // Angle\n                angle = (-array[0] * Math.PI) / 180\n\n                if (array.length >= 3) {\n                  // Center x, y\n                  cx = array[1]\n                  cy = array[2]\n                }\n\n                // Rotate around center (cx, cy)\n                tempTransform1.identity().translate(-cx, -cy)\n                tempTransform2.identity().rotate(angle)\n                tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                tempTransform1.identity().translate(cx, cy)\n                currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n              }\n\n              break\n\n            case 'scale':\n              if (array.length >= 1) {\n                var scaleX = array[0]\n                var scaleY = scaleX\n\n                if (array.length >= 2) {\n                  scaleY = array[1]\n                }\n\n                currentTransform.scale(scaleX, scaleY)\n              }\n\n              break\n\n            case 'skewX':\n              if (array.length === 1) {\n                currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n              }\n\n              break\n\n            case 'skewY':\n              if (array.length === 1) {\n                currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n              }\n\n              break\n\n            case 'matrix':\n              if (array.length === 6) {\n                currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n              }\n\n              break\n          }\n        }\n\n        transform.premultiply(currentTransform)\n      }\n\n      return transform\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n        v2.set(tempV3.x, tempV3.y)\n      }\n\n      var isRotated = isTransformRotated(m)\n\n      var tempV2 = new Vector2()\n      var tempV3 = new Vector3()\n\n      var subPaths = path.subPaths\n\n      for (var i = 0, n = subPaths.length; i < n; i++) {\n        var subPath = subPaths[i]\n        var curves = subPath.curves\n\n        for (var j = 0; j < curves.length; j++) {\n          var curve = curves[j]\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n            transfVec2(curve.v3)\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isEllipseCurve) {\n            tempV2.set(curve.aX, curve.aY)\n            transfVec2(tempV2)\n            curve.aX = tempV2.x\n            curve.aY = tempV2.y\n\n            curve.xRadius *= getTransformScaleX(m)\n            curve.yRadius *= getTransformScaleY(m)\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0\n    }\n\n    function getTransformScaleX(m) {\n      var te = m.elements\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n    }\n\n    function getTransformScaleY(m) {\n      var te = m.elements\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n    }\n\n    //\n\n    var paths = []\n\n    var transformStack = []\n\n    var tempTransform0 = new Matrix3()\n    var tempTransform1 = new Matrix3()\n    var tempTransform2 = new Matrix3()\n    var tempTransform3 = new Matrix3()\n\n    var currentTransform = new Matrix3()\n\n    var xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n    parseNode(xml.documentElement, { fill: '#000' })\n\n    // console.log( paths );\n\n    return paths\n  }\n}\n\nexport { SVGLoader }\n","import * as THREE from 'three'\nimport flatten from 'lodash-es/flatten'\nimport { SVGLoader as loader } from './SVGLoader'\nimport './styles.css'\n\nconst doubleSide = THREE.DoubleSide\nconst deg = THREE.Math.degToRad\nconst colors = ['#21242d', '#ea5158', '#0d4663', '#ffbcb7', '#2d4a3e', '#8bd8d2']\nconst svgs = ['night', 'city', 'morning', 'tubes', 'woods', 'beach']\n  .map(name => `https://raw.githubusercontent.com/drcmda/react-three-fiber/master/examples/resources/images/svg/${name}.svg`)\n  .map(\n    url =>\n      new Promise(resolve =>\n        new loader().load(url, shapes =>\n          resolve(flatten(shapes.map((group, index) => group.toShapes(true).map(shape => ({ shape, color: group.color, index })))))\n        )\n      )\n  )\n\nexport { svgs, colors, deg, doubleSide }\n","import ReactDOM from 'react-dom'\nimport React, { useState, useEffect } from 'react'\n// A React renderer for Three-js: https://github.com/drcmda/react-three-fiber\nimport { Canvas } from 'react-three-fiber'\n// A React x-platform animation library: https://github.com/react-spring/react-spring\nimport { useTransition, useSpring, animated as a } from 'react-spring/three'\nimport { svgs, colors, deg, doubleSide } from './resources/helpers'\n\n/** This component renders a shape */\nfunction Shape({ shape, rotation, position, color, opacity, index }) {\n  return (\n    <a.mesh rotation={rotation} position={position.interpolate((x, y, z) => [x, y, z + -index * 50])}>\n      <a.meshPhongMaterial attach=\"material\" color={color} opacity={opacity} side={doubleSide} depthWrite={false} transparent />\n      <shapeBufferGeometry attach=\"geometry\" args={[shape]} />\n    </a.mesh>\n  )\n}\n\n/** This component sets up a background plane and transitions a group of shapes */\nfunction Scene() {\n  const [page, setPage] = useState(0)\n  const [shapes, setShapes] = useState([])\n  // Switches scenes every 4 seconds\n  useEffect(() => void setInterval(() => setPage(i => (i + 1) % svgs.length), 3000), [])\n  // Converts current SVG into mesh-shapes: https://threejs.org/docs/index.html#examples/loaders/SVGLoader\n  useEffect(() => void svgs[page].then(setShapes), [page])\n  // This spring controls the background color animation\n  const { color } = useSpring({ color: colors[page] })\n  // This one is like a transition group, but instead of handling div's it mounts/unmounts meshes in a fancy way\n  const transitions = useTransition(shapes, item => item.shape.uuid, {\n    from: { rotation: [-0.2, 0.9, 0], position: [0, 50, -200], opacity: 0 },\n    enter: { rotation: [0, 0, 0], position: [0, 0, 0], opacity: 1 },\n    leave: { rotation: [0.2, -0.9, 0], position: [0, -400, 200], opacity: 0 },\n    config: { mass: 30, tension: 800, friction: 190, precision: 0.0001 },\n    ...{ order: ['leave', 'enter', 'update'], trail: 15, lazy: true, unique: true, reset: true }\n  })\n  return (\n    <>\n      <mesh scale={[20000, 20000, 1]} rotation={[0, deg(-20), 0]}>\n        <planeGeometry attach=\"geometry\" args={[1, 1]} />\n        <a.meshPhongMaterial attach=\"material\" color={color} depthTest={false} />\n      </mesh>\n      <group position={[1600, -700, page]} rotation={[0, deg(180), 0]}>\n        {transitions.map(({ item, key, props }) => (\n          <Shape key={key} {...item} {...props} />\n        ))}\n      </group>\n    </>\n  )\n}\n\n/** Main component */\nfunction App() {\n  return (\n    <div class=\"main\">\n      <Canvas invalidateFrameloop camera={{ fov: 90, position: [0, 0, 1800], rotation: [0, deg(-20), deg(180)], near: 0.1, far: 20000 }}>\n        <ambientLight intensity={0.5} />\n        <spotLight intensity={0.5} position={[300, 300, 4000]} />\n        <Scene />\n      </Canvas>\n      <a href=\"https://github.com/drcmda/react-three-fiber\" class=\"top-left\" children=\"Github\" />\n      <a href=\"https://twitter.com/0xca0a\" class=\"top-right\" children=\"Twitter\" />\n      <a href=\"https://github.com/react-spring/react-spring\" class=\"bottom-left\" children=\"+ react-spring\" />\n      <a href=\"https://www.instagram.com/tina.henschel/\" class=\"bottom-right\" children=\"Illustrations @ Tina Henschel\" />\n      <span class=\"header\">REACT THREE FIBER</span>\n    </div>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}